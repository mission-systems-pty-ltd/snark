#!/usr/bin/env python3

import argparse
import os
from signal import signal, SIGPIPE, SIG_DFL
import sys

import rclpy
import comma.csv
import comma.application
from snark.ros2 import convert, detail
from rosidl_runtime_py import message_to_yaml
from rosidl_runtime_py.utilities import get_message


VERBOSE = False

def say( msg: str, scriptname=os.path.basename( sys.argv[0] )):
    print( f"{scriptname}: {msg}", file=sys.stderr )

def verbose( msg: str ):
    if VERBOSE: say( msg )


help_description = """
Take CSV records on stdin, publish on a given ROS topic

TODO: fix binary (currently only ascii mode works)

TODO: load message type from .msg file
"""

help_examples = """
Examples:
    Forward ROS messages (e.g., to illustrate the principle or debug), start with trying --dry-run
        Forward with buffering:
            ros2-to-csv --topic some-topic | ros2-from-csv --topic some-topic
        Forward without buffering:
            ros2-to-csv --topic some-topic | ros2-from-csv --topic some-topic --flush
        Print to stdout:
            ros2-to-csv --topic some-topic | ros2-from-csv --topic some-topic --flush --dry-run

    Using message types offline, try it:
        Imply package from message type:
            echo 1,2,3 | ros2-from-csv --type geometry_msgs.msg.Point --format 3f --dry
        Explicitly specify package with message type definition:
            echo 1,2,3 | ros2-from-csv --import geometry_msgs.msg --type geometry_msgs.msg.Point --format 3f --dry
"""

def command_line_options():
    parser = argparse.ArgumentParser(description=help_description, epilog=help_examples, formatter_class=argparse.RawDescriptionHelpFormatter, conflict_handler='resolve')
    parser.add_argument('--index-output-fields', help='Output array fields with indices, e.g., output "array[0],array[1],array[2]", not "array"', action='store_true')
    parser.add_argument('--message-type', '--type', help='Message type, useful for debugging', type=str)
    parser.add_argument('--node-name', '--node', default='ros2_from_csv', help='Message type, useful for debugging', type=str)
    parser.add_argument('--output-fields', help='Output input CSV fields and exit', action='store_true')
    parser.add_argument('--output-format', help='Output format for input fields and exit', action='store_true')
    parser.add_argument('--topic', nargs='?', help='Topic', type=str)
    parser.add_argument('--verbose', '-v', help='Chat more', action='store_true')
    comma.csv.add_options(parser)
    comma.application.remove_argparse_options(parser, ['-b', '--binary', '--format'])
    group_fmt = parser.add_mutually_exclusive_group()
    group_fmt.add_argument('--format', help='In ASCII mode, format hint string containing the types of the input CSV data', type=str)
    group_fmt.add_argument('-b', '--binary', help='In binary mode, format string containing the types of the input CSV data', type=str)
    group_dry = parser.add_mutually_exclusive_group()
    group_dry.add_argument('--dry-run', '--dry', help='Output messages to stdout, do not send to topic', action='store_true')
    group_dry.add_argument('--ros-queue-size', '--ros-queue', '--queue-size', '--queue', metavar='NUM', default=1, help='Length of ROS publisher queue', type=int)
    args = parser.parse_args()
    return args


def main():
    # Do not want the IOError message trace. Don't use this if using sockets.
    # See https://docs.python.org/3/library/signal.html#note-on-sigpipe for more
    signal( SIGPIPE, SIG_DFL )

    global VERBOSE
    args = command_line_options()
    VERBOSE = args.verbose

    if args.dry_run:
        import numpy
        numpy.set_printoptions( linewidth=numpy.inf, threshold=numpy.inf,
                                precision=args.precision and args.precision or numpy.get_printoptions()['precision'] )

    if args.topic is None and not args.dry_run:
        say( "please specify --topic" )
        sys.exit(1)

    rclpy.init()  # Initialize ROS2 client library
    node = rclpy.create_node( args.node_name )

    msg_type = args.message_type.replace( '.', '/' )

    verbose( f"looking for message {msg_type}" )
    msg_class = get_message( msg_type )
    record_type, record_ctor = convert.ros_message_to_csv_record( msg_class() )

    if args.format or args.binary:
        formats = args.format if args.format else args.binary
        fields = args.fields if args.fields else detail.command_line.fields_of_record( record_type, args.index_output_fields )
        lengths = detail.command_line.lengths_of_strings( fields, comma.csv.format.expand( formats ))
        record_type, record_ctor = convert.ros_message_to_csv_record( msg_class(), lengths )

    if args.output_fields:
        print( ','.join( detail.command_line.fields_of_record( record_type, args.index_output_fields )))
        sys.exit(0)

    if args.output_format:
        print( ','.join( [comma.csv.format.from_numpy(f) for f in record_type.format.split(',')] ))
        sys.exit(0)

    format = ','.join( comma.csv.format.to_numpy( args.binary and args.binary or args.format, compress=True ))
    binary = not not args.binary

    # for details see https://gitlab.com/orthographic/comma/-/wikis/csv/writing-your-own-csv-application-in-python
    istream = comma.csv.stream( record_type,   # of type comma.csv.struct
                                delimiter=args.delimiter, fields=args.fields,
                                format=format, binary=binary, default_values=None, flush=args.flush)

    message = msg_class()
    assign = record_type.assign( message, convert.from_csv_supported_types )

    if args.dry_run:
        verbose( "dry run, printing messages to stdout" )
    else:
        publisher = node.create_publisher( msg_class, args.topic, qos_profile=rclpy.qos.QoSProfile( depth=args.ros_queue_size ))
        verbose( "publishing to topic '%s'..." % args.topic )

    for records in istream:
        for record in records:
            if args.verbose and not args.dry_run: print( message )
            assign( record )
            if args.dry_run:
                print( message_to_yaml( message ))
            else:
                publisher.publish( message )


if __name__ == '__main__':
    main()
